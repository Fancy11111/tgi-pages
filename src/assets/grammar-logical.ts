/* AutoGenerated Code, changes may be overwritten
* INPUT GRAMMAR:
* start := logicalExpression
* logicalTrue := text='[Tt]([Rr][Uu][Ee])?|1|[Ww]([Aa][Hh][Rr])?'
*                .value = boolean { return true; }
* logicalFalse := text='[Ff]([Aa][Ll][Ss]([Ee]|[Cc][Hh]))?|0'
*                 .value = boolean { return false; }
* logicalData := data={ logicalTrue | logicalFalse }
*                .value = boolean { return this.data.value; }
* logicalNot := text={'NOT' | 'Not' | 'not' | '!'}
*               .value = String { return 'not'; }
* logicalUnaryOperator := data={ logicalNot }
*                         .value = String { return this.data.value; }
* logicalImplies := text={ 'IMPLIES' | 'Implies' | 'implies' | '=>' }
*                   .value = String { return 'implies'; }
* logicalAnd := text={ 'AND' | 'And' | 'and' | '&' | '&&' }
*               .value = String { return 'and'; }
* logicalOr := text={ 'OR' | 'Or' | 'or' | '|' | '||' }
*              .value = String { return 'or'; }
* logicalXor := text={ 'XOR' | 'Xor' | 'xor' | '^' }
*               .value = String { return 'xor'; }
* logicalNand := text={ 'NAND' | 'Nand' | 'nand' | '!&' | '!&&' }
*                .value = String { return 'nand'; }
* logicalNor := text={ 'NOR' | 'Nor' | 'nor' | '!|' | '!||' }
*               .value = String { return 'nor'; }
* logicalEquals := text={ 'EQUALS' | 'Equals' | 'equals' | '=' | '==' | '<==>' | '<=>' }
*                  .value = String { return 'equals'; }
* logicalBinaryOperator := data={ logicalImplies | logicalAnd | logicalOr | logicalXor | logicalNand | logicalNor | logicalEquals }
*                          .value = String { return this.data.value; }
* logicalTerm := right=logicalData | operator=logicalUnaryOperator right=logicalExpression | '\(' right=logicalExpression '\)'
* logicalExpression := left=logicalTerm operator=logicalBinaryOperator right=logicalTerm | right=logicalTerm
*/
type Nullable<T> = T | null;
type $$RuleType<T> = (log?: (msg: string) => void) => Nullable<T>;
export interface ContextRecorder {
    record(pos: PosInfo, depth: number, result: any, negating: boolean, extraInfo: string[]): void;
}
interface ASTNodeIntf {
    kind: ASTKinds;
}
export enum ASTKinds {
    start = "start",
    logicalTrue = "logicalTrue",
    logicalFalse = "logicalFalse",
    logicalData = "logicalData",
    logicalData_$0_1 = "logicalData_$0_1",
    logicalData_$0_2 = "logicalData_$0_2",
    logicalNot = "logicalNot",
    logicalNot_$0_1 = "logicalNot_$0_1",
    logicalNot_$0_2 = "logicalNot_$0_2",
    logicalNot_$0_3 = "logicalNot_$0_3",
    logicalNot_$0_4 = "logicalNot_$0_4",
    logicalUnaryOperator = "logicalUnaryOperator",
    logicalUnaryOperator_$0 = "logicalUnaryOperator_$0",
    logicalImplies = "logicalImplies",
    logicalImplies_$0_1 = "logicalImplies_$0_1",
    logicalImplies_$0_2 = "logicalImplies_$0_2",
    logicalImplies_$0_3 = "logicalImplies_$0_3",
    logicalImplies_$0_4 = "logicalImplies_$0_4",
    logicalAnd = "logicalAnd",
    logicalAnd_$0_1 = "logicalAnd_$0_1",
    logicalAnd_$0_2 = "logicalAnd_$0_2",
    logicalAnd_$0_3 = "logicalAnd_$0_3",
    logicalAnd_$0_4 = "logicalAnd_$0_4",
    logicalAnd_$0_5 = "logicalAnd_$0_5",
    logicalOr = "logicalOr",
    logicalOr_$0_1 = "logicalOr_$0_1",
    logicalOr_$0_2 = "logicalOr_$0_2",
    logicalOr_$0_3 = "logicalOr_$0_3",
    logicalOr_$0_4 = "logicalOr_$0_4",
    logicalOr_$0_5 = "logicalOr_$0_5",
    logicalXor = "logicalXor",
    logicalXor_$0_1 = "logicalXor_$0_1",
    logicalXor_$0_2 = "logicalXor_$0_2",
    logicalXor_$0_3 = "logicalXor_$0_3",
    logicalXor_$0_4 = "logicalXor_$0_4",
    logicalNand = "logicalNand",
    logicalNand_$0_1 = "logicalNand_$0_1",
    logicalNand_$0_2 = "logicalNand_$0_2",
    logicalNand_$0_3 = "logicalNand_$0_3",
    logicalNand_$0_4 = "logicalNand_$0_4",
    logicalNand_$0_5 = "logicalNand_$0_5",
    logicalNor = "logicalNor",
    logicalNor_$0_1 = "logicalNor_$0_1",
    logicalNor_$0_2 = "logicalNor_$0_2",
    logicalNor_$0_3 = "logicalNor_$0_3",
    logicalNor_$0_4 = "logicalNor_$0_4",
    logicalNor_$0_5 = "logicalNor_$0_5",
    logicalEquals = "logicalEquals",
    logicalEquals_$0_1 = "logicalEquals_$0_1",
    logicalEquals_$0_2 = "logicalEquals_$0_2",
    logicalEquals_$0_3 = "logicalEquals_$0_3",
    logicalEquals_$0_4 = "logicalEquals_$0_4",
    logicalEquals_$0_5 = "logicalEquals_$0_5",
    logicalEquals_$0_6 = "logicalEquals_$0_6",
    logicalEquals_$0_7 = "logicalEquals_$0_7",
    logicalBinaryOperator = "logicalBinaryOperator",
    logicalBinaryOperator_$0_1 = "logicalBinaryOperator_$0_1",
    logicalBinaryOperator_$0_2 = "logicalBinaryOperator_$0_2",
    logicalBinaryOperator_$0_3 = "logicalBinaryOperator_$0_3",
    logicalBinaryOperator_$0_4 = "logicalBinaryOperator_$0_4",
    logicalBinaryOperator_$0_5 = "logicalBinaryOperator_$0_5",
    logicalBinaryOperator_$0_6 = "logicalBinaryOperator_$0_6",
    logicalBinaryOperator_$0_7 = "logicalBinaryOperator_$0_7",
    logicalTerm_1 = "logicalTerm_1",
    logicalTerm_2 = "logicalTerm_2",
    logicalTerm_3 = "logicalTerm_3",
    logicalExpression_1 = "logicalExpression_1",
    logicalExpression_2 = "logicalExpression_2",
}
export type start = logicalExpression;
export class logicalTrue {
    public kind: ASTKinds.logicalTrue = ASTKinds.logicalTrue;
    public text: string;
    public value: boolean;
    constructor(text: string){
        this.text = text;
        this.value = ((): boolean => {
        return true;
        })();
    }
}
export class logicalFalse {
    public kind: ASTKinds.logicalFalse = ASTKinds.logicalFalse;
    public text: string;
    public value: boolean;
    constructor(text: string){
        this.text = text;
        this.value = ((): boolean => {
        return false;
        })();
    }
}
export class logicalData {
    public kind: ASTKinds.logicalData = ASTKinds.logicalData;
    public data: logicalData_$0;
    public value: boolean;
    constructor(data: logicalData_$0){
        this.data = data;
        this.value = ((): boolean => {
        return this.data.value;
        })();
    }
}
export type logicalData_$0 = logicalData_$0_1 | logicalData_$0_2;
export type logicalData_$0_1 = logicalTrue;
export type logicalData_$0_2 = logicalFalse;
export class logicalNot {
    public kind: ASTKinds.logicalNot = ASTKinds.logicalNot;
    public text: logicalNot_$0;
    public value: String;
    constructor(text: logicalNot_$0){
        this.text = text;
        this.value = ((): String => {
        return 'not';
        })();
    }
}
export type logicalNot_$0 = logicalNot_$0_1 | logicalNot_$0_2 | logicalNot_$0_3 | logicalNot_$0_4;
export type logicalNot_$0_1 = string;
export type logicalNot_$0_2 = string;
export type logicalNot_$0_3 = string;
export type logicalNot_$0_4 = string;
export class logicalUnaryOperator {
    public kind: ASTKinds.logicalUnaryOperator = ASTKinds.logicalUnaryOperator;
    public data: logicalUnaryOperator_$0;
    public value: String;
    constructor(data: logicalUnaryOperator_$0){
        this.data = data;
        this.value = ((): String => {
        return this.data.value;
        })();
    }
}
export type logicalUnaryOperator_$0 = logicalNot;
export class logicalImplies {
    public kind: ASTKinds.logicalImplies = ASTKinds.logicalImplies;
    public text: logicalImplies_$0;
    public value: String;
    constructor(text: logicalImplies_$0){
        this.text = text;
        this.value = ((): String => {
        return 'implies';
        })();
    }
}
export type logicalImplies_$0 = logicalImplies_$0_1 | logicalImplies_$0_2 | logicalImplies_$0_3 | logicalImplies_$0_4;
export type logicalImplies_$0_1 = string;
export type logicalImplies_$0_2 = string;
export type logicalImplies_$0_3 = string;
export type logicalImplies_$0_4 = string;
export class logicalAnd {
    public kind: ASTKinds.logicalAnd = ASTKinds.logicalAnd;
    public text: logicalAnd_$0;
    public value: String;
    constructor(text: logicalAnd_$0){
        this.text = text;
        this.value = ((): String => {
        return 'and';
        })();
    }
}
export type logicalAnd_$0 = logicalAnd_$0_1 | logicalAnd_$0_2 | logicalAnd_$0_3 | logicalAnd_$0_4 | logicalAnd_$0_5;
export type logicalAnd_$0_1 = string;
export type logicalAnd_$0_2 = string;
export type logicalAnd_$0_3 = string;
export type logicalAnd_$0_4 = string;
export type logicalAnd_$0_5 = string;
export class logicalOr {
    public kind: ASTKinds.logicalOr = ASTKinds.logicalOr;
    public text: logicalOr_$0;
    public value: String;
    constructor(text: logicalOr_$0){
        this.text = text;
        this.value = ((): String => {
        return 'or';
        })();
    }
}
export type logicalOr_$0 = logicalOr_$0_1 | logicalOr_$0_2 | logicalOr_$0_3 | logicalOr_$0_4 | logicalOr_$0_5;
export type logicalOr_$0_1 = string;
export type logicalOr_$0_2 = string;
export type logicalOr_$0_3 = string;
export type logicalOr_$0_4 = string;
export type logicalOr_$0_5 = string;
export class logicalXor {
    public kind: ASTKinds.logicalXor = ASTKinds.logicalXor;
    public text: logicalXor_$0;
    public value: String;
    constructor(text: logicalXor_$0){
        this.text = text;
        this.value = ((): String => {
        return 'xor';
        })();
    }
}
export type logicalXor_$0 = logicalXor_$0_1 | logicalXor_$0_2 | logicalXor_$0_3 | logicalXor_$0_4;
export type logicalXor_$0_1 = string;
export type logicalXor_$0_2 = string;
export type logicalXor_$0_3 = string;
export type logicalXor_$0_4 = string;
export class logicalNand {
    public kind: ASTKinds.logicalNand = ASTKinds.logicalNand;
    public text: logicalNand_$0;
    public value: String;
    constructor(text: logicalNand_$0){
        this.text = text;
        this.value = ((): String => {
        return 'nand';
        })();
    }
}
export type logicalNand_$0 = logicalNand_$0_1 | logicalNand_$0_2 | logicalNand_$0_3 | logicalNand_$0_4 | logicalNand_$0_5;
export type logicalNand_$0_1 = string;
export type logicalNand_$0_2 = string;
export type logicalNand_$0_3 = string;
export type logicalNand_$0_4 = string;
export type logicalNand_$0_5 = string;
export class logicalNor {
    public kind: ASTKinds.logicalNor = ASTKinds.logicalNor;
    public text: logicalNor_$0;
    public value: String;
    constructor(text: logicalNor_$0){
        this.text = text;
        this.value = ((): String => {
        return 'nor';
        })();
    }
}
export type logicalNor_$0 = logicalNor_$0_1 | logicalNor_$0_2 | logicalNor_$0_3 | logicalNor_$0_4 | logicalNor_$0_5;
export type logicalNor_$0_1 = string;
export type logicalNor_$0_2 = string;
export type logicalNor_$0_3 = string;
export type logicalNor_$0_4 = string;
export type logicalNor_$0_5 = string;
export class logicalEquals {
    public kind: ASTKinds.logicalEquals = ASTKinds.logicalEquals;
    public text: logicalEquals_$0;
    public value: String;
    constructor(text: logicalEquals_$0){
        this.text = text;
        this.value = ((): String => {
        return 'equals';
        })();
    }
}
export type logicalEquals_$0 = logicalEquals_$0_1 | logicalEquals_$0_2 | logicalEquals_$0_3 | logicalEquals_$0_4 | logicalEquals_$0_5 | logicalEquals_$0_6 | logicalEquals_$0_7;
export type logicalEquals_$0_1 = string;
export type logicalEquals_$0_2 = string;
export type logicalEquals_$0_3 = string;
export type logicalEquals_$0_4 = string;
export type logicalEquals_$0_5 = string;
export type logicalEquals_$0_6 = string;
export type logicalEquals_$0_7 = string;
export class logicalBinaryOperator {
    public kind: ASTKinds.logicalBinaryOperator = ASTKinds.logicalBinaryOperator;
    public data: logicalBinaryOperator_$0;
    public value: String;
    constructor(data: logicalBinaryOperator_$0){
        this.data = data;
        this.value = ((): String => {
        return this.data.value;
        })();
    }
}
export type logicalBinaryOperator_$0 = logicalBinaryOperator_$0_1 | logicalBinaryOperator_$0_2 | logicalBinaryOperator_$0_3 | logicalBinaryOperator_$0_4 | logicalBinaryOperator_$0_5 | logicalBinaryOperator_$0_6 | logicalBinaryOperator_$0_7;
export type logicalBinaryOperator_$0_1 = logicalImplies;
export type logicalBinaryOperator_$0_2 = logicalAnd;
export type logicalBinaryOperator_$0_3 = logicalOr;
export type logicalBinaryOperator_$0_4 = logicalXor;
export type logicalBinaryOperator_$0_5 = logicalNand;
export type logicalBinaryOperator_$0_6 = logicalNor;
export type logicalBinaryOperator_$0_7 = logicalEquals;
export type logicalTerm = logicalTerm_1 | logicalTerm_2 | logicalTerm_3;
export interface logicalTerm_1 {
    kind: ASTKinds.logicalTerm_1;
    right: logicalData;
}
export interface logicalTerm_2 {
    kind: ASTKinds.logicalTerm_2;
    operator: logicalUnaryOperator;
    right: logicalExpression;
}
export interface logicalTerm_3 {
    kind: ASTKinds.logicalTerm_3;
    right: logicalExpression;
}
export type logicalExpression = logicalExpression_1 | logicalExpression_2;
export interface logicalExpression_1 {
    kind: ASTKinds.logicalExpression_1;
    left: logicalTerm;
    operator: logicalBinaryOperator;
    right: logicalTerm;
}
export interface logicalExpression_2 {
    kind: ASTKinds.logicalExpression_2;
    right: logicalTerm;
}
export class Parser {
    private readonly input: string;
    private pos: PosInfo;
    private negating: boolean = false;
    constructor(input: string) {
        this.pos = {overallPos: 0, line: 1, offset: 0};
        this.input = input;
    }
    public reset(pos: PosInfo) {
        this.pos = pos;
    }
    public finished(): boolean {
        return this.pos.overallPos === this.input.length;
    }
    public matchstart($$dpth: number, $$cr?: ContextRecorder): Nullable<start> {
        return this.matchlogicalExpression($$dpth + 1, $$cr);
    }
    public matchlogicalTrue($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalTrue> {
        return this.runner<logicalTrue>($$dpth,
            (log) => {
                if (log) {
                    log("logicalTrue");
                }
                let $scope$text: Nullable<string>;
                let $$res: Nullable<logicalTrue> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:[Tt]([Rr][Uu][Ee])?|1|[Ww]([Aa][Hh][Rr])?)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new logicalTrue($scope$text);
                }
                return $$res;
            }, $$cr)();
    }
    public matchlogicalFalse($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalFalse> {
        return this.runner<logicalFalse>($$dpth,
            (log) => {
                if (log) {
                    log("logicalFalse");
                }
                let $scope$text: Nullable<string>;
                let $$res: Nullable<logicalFalse> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:[Ff]([Aa][Ll][Ss]([Ee]|[Cc][Hh]))?|0)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new logicalFalse($scope$text);
                }
                return $$res;
            }, $$cr)();
    }
    public matchlogicalData($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalData> {
        return this.runner<logicalData>($$dpth,
            (log) => {
                if (log) {
                    log("logicalData");
                }
                let $scope$data: Nullable<logicalData_$0>;
                let $$res: Nullable<logicalData> = null;
                if (true
                    && ($scope$data = this.matchlogicalData_$0($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new logicalData($scope$data);
                }
                return $$res;
            }, $$cr)();
    }
    public matchlogicalData_$0($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalData_$0> {
        return this.choice<logicalData_$0>([
            () => this.matchlogicalData_$0_1($$dpth + 1, $$cr),
            () => this.matchlogicalData_$0_2($$dpth + 1, $$cr),
        ]);
    }
    public matchlogicalData_$0_1($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalData_$0_1> {
        return this.matchlogicalTrue($$dpth + 1, $$cr);
    }
    public matchlogicalData_$0_2($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalData_$0_2> {
        return this.matchlogicalFalse($$dpth + 1, $$cr);
    }
    public matchlogicalNot($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalNot> {
        return this.runner<logicalNot>($$dpth,
            (log) => {
                if (log) {
                    log("logicalNot");
                }
                let $scope$text: Nullable<logicalNot_$0>;
                let $$res: Nullable<logicalNot> = null;
                if (true
                    && ($scope$text = this.matchlogicalNot_$0($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new logicalNot($scope$text);
                }
                return $$res;
            }, $$cr)();
    }
    public matchlogicalNot_$0($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalNot_$0> {
        return this.choice<logicalNot_$0>([
            () => this.matchlogicalNot_$0_1($$dpth + 1, $$cr),
            () => this.matchlogicalNot_$0_2($$dpth + 1, $$cr),
            () => this.matchlogicalNot_$0_3($$dpth + 1, $$cr),
            () => this.matchlogicalNot_$0_4($$dpth + 1, $$cr),
        ]);
    }
    public matchlogicalNot_$0_1($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalNot_$0_1> {
        return this.regexAccept(String.raw`(?:NOT)`, $$dpth + 1, $$cr);
    }
    public matchlogicalNot_$0_2($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalNot_$0_2> {
        return this.regexAccept(String.raw`(?:Not)`, $$dpth + 1, $$cr);
    }
    public matchlogicalNot_$0_3($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalNot_$0_3> {
        return this.regexAccept(String.raw`(?:not)`, $$dpth + 1, $$cr);
    }
    public matchlogicalNot_$0_4($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalNot_$0_4> {
        return this.regexAccept(String.raw`(?:!)`, $$dpth + 1, $$cr);
    }
    public matchlogicalUnaryOperator($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalUnaryOperator> {
        return this.runner<logicalUnaryOperator>($$dpth,
            (log) => {
                if (log) {
                    log("logicalUnaryOperator");
                }
                let $scope$data: Nullable<logicalUnaryOperator_$0>;
                let $$res: Nullable<logicalUnaryOperator> = null;
                if (true
                    && ($scope$data = this.matchlogicalUnaryOperator_$0($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new logicalUnaryOperator($scope$data);
                }
                return $$res;
            }, $$cr)();
    }
    public matchlogicalUnaryOperator_$0($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalUnaryOperator_$0> {
        return this.matchlogicalNot($$dpth + 1, $$cr);
    }
    public matchlogicalImplies($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalImplies> {
        return this.runner<logicalImplies>($$dpth,
            (log) => {
                if (log) {
                    log("logicalImplies");
                }
                let $scope$text: Nullable<logicalImplies_$0>;
                let $$res: Nullable<logicalImplies> = null;
                if (true
                    && ($scope$text = this.matchlogicalImplies_$0($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new logicalImplies($scope$text);
                }
                return $$res;
            }, $$cr)();
    }
    public matchlogicalImplies_$0($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalImplies_$0> {
        return this.choice<logicalImplies_$0>([
            () => this.matchlogicalImplies_$0_1($$dpth + 1, $$cr),
            () => this.matchlogicalImplies_$0_2($$dpth + 1, $$cr),
            () => this.matchlogicalImplies_$0_3($$dpth + 1, $$cr),
            () => this.matchlogicalImplies_$0_4($$dpth + 1, $$cr),
        ]);
    }
    public matchlogicalImplies_$0_1($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalImplies_$0_1> {
        return this.regexAccept(String.raw`(?:IMPLIES)`, $$dpth + 1, $$cr);
    }
    public matchlogicalImplies_$0_2($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalImplies_$0_2> {
        return this.regexAccept(String.raw`(?:Implies)`, $$dpth + 1, $$cr);
    }
    public matchlogicalImplies_$0_3($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalImplies_$0_3> {
        return this.regexAccept(String.raw`(?:implies)`, $$dpth + 1, $$cr);
    }
    public matchlogicalImplies_$0_4($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalImplies_$0_4> {
        return this.regexAccept(String.raw`(?:=>)`, $$dpth + 1, $$cr);
    }
    public matchlogicalAnd($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalAnd> {
        return this.runner<logicalAnd>($$dpth,
            (log) => {
                if (log) {
                    log("logicalAnd");
                }
                let $scope$text: Nullable<logicalAnd_$0>;
                let $$res: Nullable<logicalAnd> = null;
                if (true
                    && ($scope$text = this.matchlogicalAnd_$0($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new logicalAnd($scope$text);
                }
                return $$res;
            }, $$cr)();
    }
    public matchlogicalAnd_$0($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalAnd_$0> {
        return this.choice<logicalAnd_$0>([
            () => this.matchlogicalAnd_$0_1($$dpth + 1, $$cr),
            () => this.matchlogicalAnd_$0_2($$dpth + 1, $$cr),
            () => this.matchlogicalAnd_$0_3($$dpth + 1, $$cr),
            () => this.matchlogicalAnd_$0_4($$dpth + 1, $$cr),
            () => this.matchlogicalAnd_$0_5($$dpth + 1, $$cr),
        ]);
    }
    public matchlogicalAnd_$0_1($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalAnd_$0_1> {
        return this.regexAccept(String.raw`(?:AND)`, $$dpth + 1, $$cr);
    }
    public matchlogicalAnd_$0_2($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalAnd_$0_2> {
        return this.regexAccept(String.raw`(?:And)`, $$dpth + 1, $$cr);
    }
    public matchlogicalAnd_$0_3($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalAnd_$0_3> {
        return this.regexAccept(String.raw`(?:and)`, $$dpth + 1, $$cr);
    }
    public matchlogicalAnd_$0_4($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalAnd_$0_4> {
        return this.regexAccept(String.raw`(?:&)`, $$dpth + 1, $$cr);
    }
    public matchlogicalAnd_$0_5($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalAnd_$0_5> {
        return this.regexAccept(String.raw`(?:&&)`, $$dpth + 1, $$cr);
    }
    public matchlogicalOr($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalOr> {
        return this.runner<logicalOr>($$dpth,
            (log) => {
                if (log) {
                    log("logicalOr");
                }
                let $scope$text: Nullable<logicalOr_$0>;
                let $$res: Nullable<logicalOr> = null;
                if (true
                    && ($scope$text = this.matchlogicalOr_$0($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new logicalOr($scope$text);
                }
                return $$res;
            }, $$cr)();
    }
    public matchlogicalOr_$0($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalOr_$0> {
        return this.choice<logicalOr_$0>([
            () => this.matchlogicalOr_$0_1($$dpth + 1, $$cr),
            () => this.matchlogicalOr_$0_2($$dpth + 1, $$cr),
            () => this.matchlogicalOr_$0_3($$dpth + 1, $$cr),
            () => this.matchlogicalOr_$0_4($$dpth + 1, $$cr),
            () => this.matchlogicalOr_$0_5($$dpth + 1, $$cr),
        ]);
    }
    public matchlogicalOr_$0_1($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalOr_$0_1> {
        return this.regexAccept(String.raw`(?:OR)`, $$dpth + 1, $$cr);
    }
    public matchlogicalOr_$0_2($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalOr_$0_2> {
        return this.regexAccept(String.raw`(?:Or)`, $$dpth + 1, $$cr);
    }
    public matchlogicalOr_$0_3($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalOr_$0_3> {
        return this.regexAccept(String.raw`(?:or)`, $$dpth + 1, $$cr);
    }
    public matchlogicalOr_$0_4($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalOr_$0_4> {
        return this.regexAccept(String.raw`(?:|)`, $$dpth + 1, $$cr);
    }
    public matchlogicalOr_$0_5($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalOr_$0_5> {
        return this.regexAccept(String.raw`(?:||)`, $$dpth + 1, $$cr);
    }
    public matchlogicalXor($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalXor> {
        return this.runner<logicalXor>($$dpth,
            (log) => {
                if (log) {
                    log("logicalXor");
                }
                let $scope$text: Nullable<logicalXor_$0>;
                let $$res: Nullable<logicalXor> = null;
                if (true
                    && ($scope$text = this.matchlogicalXor_$0($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new logicalXor($scope$text);
                }
                return $$res;
            }, $$cr)();
    }
    public matchlogicalXor_$0($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalXor_$0> {
        return this.choice<logicalXor_$0>([
            () => this.matchlogicalXor_$0_1($$dpth + 1, $$cr),
            () => this.matchlogicalXor_$0_2($$dpth + 1, $$cr),
            () => this.matchlogicalXor_$0_3($$dpth + 1, $$cr),
            () => this.matchlogicalXor_$0_4($$dpth + 1, $$cr),
        ]);
    }
    public matchlogicalXor_$0_1($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalXor_$0_1> {
        return this.regexAccept(String.raw`(?:XOR)`, $$dpth + 1, $$cr);
    }
    public matchlogicalXor_$0_2($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalXor_$0_2> {
        return this.regexAccept(String.raw`(?:Xor)`, $$dpth + 1, $$cr);
    }
    public matchlogicalXor_$0_3($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalXor_$0_3> {
        return this.regexAccept(String.raw`(?:xor)`, $$dpth + 1, $$cr);
    }
    public matchlogicalXor_$0_4($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalXor_$0_4> {
        return this.regexAccept(String.raw`(?:^)`, $$dpth + 1, $$cr);
    }
    public matchlogicalNand($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalNand> {
        return this.runner<logicalNand>($$dpth,
            (log) => {
                if (log) {
                    log("logicalNand");
                }
                let $scope$text: Nullable<logicalNand_$0>;
                let $$res: Nullable<logicalNand> = null;
                if (true
                    && ($scope$text = this.matchlogicalNand_$0($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new logicalNand($scope$text);
                }
                return $$res;
            }, $$cr)();
    }
    public matchlogicalNand_$0($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalNand_$0> {
        return this.choice<logicalNand_$0>([
            () => this.matchlogicalNand_$0_1($$dpth + 1, $$cr),
            () => this.matchlogicalNand_$0_2($$dpth + 1, $$cr),
            () => this.matchlogicalNand_$0_3($$dpth + 1, $$cr),
            () => this.matchlogicalNand_$0_4($$dpth + 1, $$cr),
            () => this.matchlogicalNand_$0_5($$dpth + 1, $$cr),
        ]);
    }
    public matchlogicalNand_$0_1($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalNand_$0_1> {
        return this.regexAccept(String.raw`(?:NAND)`, $$dpth + 1, $$cr);
    }
    public matchlogicalNand_$0_2($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalNand_$0_2> {
        return this.regexAccept(String.raw`(?:Nand)`, $$dpth + 1, $$cr);
    }
    public matchlogicalNand_$0_3($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalNand_$0_3> {
        return this.regexAccept(String.raw`(?:nand)`, $$dpth + 1, $$cr);
    }
    public matchlogicalNand_$0_4($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalNand_$0_4> {
        return this.regexAccept(String.raw`(?:!&)`, $$dpth + 1, $$cr);
    }
    public matchlogicalNand_$0_5($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalNand_$0_5> {
        return this.regexAccept(String.raw`(?:!&&)`, $$dpth + 1, $$cr);
    }
    public matchlogicalNor($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalNor> {
        return this.runner<logicalNor>($$dpth,
            (log) => {
                if (log) {
                    log("logicalNor");
                }
                let $scope$text: Nullable<logicalNor_$0>;
                let $$res: Nullable<logicalNor> = null;
                if (true
                    && ($scope$text = this.matchlogicalNor_$0($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new logicalNor($scope$text);
                }
                return $$res;
            }, $$cr)();
    }
    public matchlogicalNor_$0($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalNor_$0> {
        return this.choice<logicalNor_$0>([
            () => this.matchlogicalNor_$0_1($$dpth + 1, $$cr),
            () => this.matchlogicalNor_$0_2($$dpth + 1, $$cr),
            () => this.matchlogicalNor_$0_3($$dpth + 1, $$cr),
            () => this.matchlogicalNor_$0_4($$dpth + 1, $$cr),
            () => this.matchlogicalNor_$0_5($$dpth + 1, $$cr),
        ]);
    }
    public matchlogicalNor_$0_1($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalNor_$0_1> {
        return this.regexAccept(String.raw`(?:NOR)`, $$dpth + 1, $$cr);
    }
    public matchlogicalNor_$0_2($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalNor_$0_2> {
        return this.regexAccept(String.raw`(?:Nor)`, $$dpth + 1, $$cr);
    }
    public matchlogicalNor_$0_3($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalNor_$0_3> {
        return this.regexAccept(String.raw`(?:nor)`, $$dpth + 1, $$cr);
    }
    public matchlogicalNor_$0_4($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalNor_$0_4> {
        return this.regexAccept(String.raw`(?:!|)`, $$dpth + 1, $$cr);
    }
    public matchlogicalNor_$0_5($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalNor_$0_5> {
        return this.regexAccept(String.raw`(?:!||)`, $$dpth + 1, $$cr);
    }
    public matchlogicalEquals($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalEquals> {
        return this.runner<logicalEquals>($$dpth,
            (log) => {
                if (log) {
                    log("logicalEquals");
                }
                let $scope$text: Nullable<logicalEquals_$0>;
                let $$res: Nullable<logicalEquals> = null;
                if (true
                    && ($scope$text = this.matchlogicalEquals_$0($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new logicalEquals($scope$text);
                }
                return $$res;
            }, $$cr)();
    }
    public matchlogicalEquals_$0($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalEquals_$0> {
        return this.choice<logicalEquals_$0>([
            () => this.matchlogicalEquals_$0_1($$dpth + 1, $$cr),
            () => this.matchlogicalEquals_$0_2($$dpth + 1, $$cr),
            () => this.matchlogicalEquals_$0_3($$dpth + 1, $$cr),
            () => this.matchlogicalEquals_$0_4($$dpth + 1, $$cr),
            () => this.matchlogicalEquals_$0_5($$dpth + 1, $$cr),
            () => this.matchlogicalEquals_$0_6($$dpth + 1, $$cr),
            () => this.matchlogicalEquals_$0_7($$dpth + 1, $$cr),
        ]);
    }
    public matchlogicalEquals_$0_1($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalEquals_$0_1> {
        return this.regexAccept(String.raw`(?:EQUALS)`, $$dpth + 1, $$cr);
    }
    public matchlogicalEquals_$0_2($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalEquals_$0_2> {
        return this.regexAccept(String.raw`(?:Equals)`, $$dpth + 1, $$cr);
    }
    public matchlogicalEquals_$0_3($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalEquals_$0_3> {
        return this.regexAccept(String.raw`(?:equals)`, $$dpth + 1, $$cr);
    }
    public matchlogicalEquals_$0_4($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalEquals_$0_4> {
        return this.regexAccept(String.raw`(?:=)`, $$dpth + 1, $$cr);
    }
    public matchlogicalEquals_$0_5($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalEquals_$0_5> {
        return this.regexAccept(String.raw`(?:==)`, $$dpth + 1, $$cr);
    }
    public matchlogicalEquals_$0_6($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalEquals_$0_6> {
        return this.regexAccept(String.raw`(?:<==>)`, $$dpth + 1, $$cr);
    }
    public matchlogicalEquals_$0_7($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalEquals_$0_7> {
        return this.regexAccept(String.raw`(?:<=>)`, $$dpth + 1, $$cr);
    }
    public matchlogicalBinaryOperator($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalBinaryOperator> {
        return this.runner<logicalBinaryOperator>($$dpth,
            (log) => {
                if (log) {
                    log("logicalBinaryOperator");
                }
                let $scope$data: Nullable<logicalBinaryOperator_$0>;
                let $$res: Nullable<logicalBinaryOperator> = null;
                if (true
                    && ($scope$data = this.matchlogicalBinaryOperator_$0($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new logicalBinaryOperator($scope$data);
                }
                return $$res;
            }, $$cr)();
    }
    public matchlogicalBinaryOperator_$0($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalBinaryOperator_$0> {
        return this.choice<logicalBinaryOperator_$0>([
            () => this.matchlogicalBinaryOperator_$0_1($$dpth + 1, $$cr),
            () => this.matchlogicalBinaryOperator_$0_2($$dpth + 1, $$cr),
            () => this.matchlogicalBinaryOperator_$0_3($$dpth + 1, $$cr),
            () => this.matchlogicalBinaryOperator_$0_4($$dpth + 1, $$cr),
            () => this.matchlogicalBinaryOperator_$0_5($$dpth + 1, $$cr),
            () => this.matchlogicalBinaryOperator_$0_6($$dpth + 1, $$cr),
            () => this.matchlogicalBinaryOperator_$0_7($$dpth + 1, $$cr),
        ]);
    }
    public matchlogicalBinaryOperator_$0_1($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalBinaryOperator_$0_1> {
        return this.matchlogicalImplies($$dpth + 1, $$cr);
    }
    public matchlogicalBinaryOperator_$0_2($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalBinaryOperator_$0_2> {
        return this.matchlogicalAnd($$dpth + 1, $$cr);
    }
    public matchlogicalBinaryOperator_$0_3($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalBinaryOperator_$0_3> {
        return this.matchlogicalOr($$dpth + 1, $$cr);
    }
    public matchlogicalBinaryOperator_$0_4($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalBinaryOperator_$0_4> {
        return this.matchlogicalXor($$dpth + 1, $$cr);
    }
    public matchlogicalBinaryOperator_$0_5($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalBinaryOperator_$0_5> {
        return this.matchlogicalNand($$dpth + 1, $$cr);
    }
    public matchlogicalBinaryOperator_$0_6($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalBinaryOperator_$0_6> {
        return this.matchlogicalNor($$dpth + 1, $$cr);
    }
    public matchlogicalBinaryOperator_$0_7($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalBinaryOperator_$0_7> {
        return this.matchlogicalEquals($$dpth + 1, $$cr);
    }
    public matchlogicalTerm($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalTerm> {
        return this.choice<logicalTerm>([
            () => this.matchlogicalTerm_1($$dpth + 1, $$cr),
            () => this.matchlogicalTerm_2($$dpth + 1, $$cr),
            () => this.matchlogicalTerm_3($$dpth + 1, $$cr),
        ]);
    }
    public matchlogicalTerm_1($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalTerm_1> {
        return this.runner<logicalTerm_1>($$dpth,
            (log) => {
                if (log) {
                    log("logicalTerm_1");
                }
                let $scope$right: Nullable<logicalData>;
                let $$res: Nullable<logicalTerm_1> = null;
                if (true
                    && ($scope$right = this.matchlogicalData($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.logicalTerm_1, right: $scope$right};
                }
                return $$res;
            }, $$cr)();
    }
    public matchlogicalTerm_2($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalTerm_2> {
        return this.runner<logicalTerm_2>($$dpth,
            (log) => {
                if (log) {
                    log("logicalTerm_2");
                }
                let $scope$operator: Nullable<logicalUnaryOperator>;
                let $scope$right: Nullable<logicalExpression>;
                let $$res: Nullable<logicalTerm_2> = null;
                if (true
                    && ($scope$operator = this.matchlogicalUnaryOperator($$dpth + 1, $$cr)) !== null
                    && ($scope$right = this.matchlogicalExpression($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.logicalTerm_2, operator: $scope$operator, right: $scope$right};
                }
                return $$res;
            }, $$cr)();
    }
    public matchlogicalTerm_3($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalTerm_3> {
        return this.runner<logicalTerm_3>($$dpth,
            (log) => {
                if (log) {
                    log("logicalTerm_3");
                }
                let $scope$right: Nullable<logicalExpression>;
                let $$res: Nullable<logicalTerm_3> = null;
                if (true
                    && this.regexAccept(String.raw`(?:\()`, $$dpth + 1, $$cr) !== null
                    && ($scope$right = this.matchlogicalExpression($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:\))`, $$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.logicalTerm_3, right: $scope$right};
                }
                return $$res;
            }, $$cr)();
    }
    public matchlogicalExpression($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalExpression> {
        return this.choice<logicalExpression>([
            () => this.matchlogicalExpression_1($$dpth + 1, $$cr),
            () => this.matchlogicalExpression_2($$dpth + 1, $$cr),
        ]);
    }
    public matchlogicalExpression_1($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalExpression_1> {
        return this.runner<logicalExpression_1>($$dpth,
            (log) => {
                if (log) {
                    log("logicalExpression_1");
                }
                let $scope$left: Nullable<logicalTerm>;
                let $scope$operator: Nullable<logicalBinaryOperator>;
                let $scope$right: Nullable<logicalTerm>;
                let $$res: Nullable<logicalExpression_1> = null;
                if (true
                    && ($scope$left = this.matchlogicalTerm($$dpth + 1, $$cr)) !== null
                    && ($scope$operator = this.matchlogicalBinaryOperator($$dpth + 1, $$cr)) !== null
                    && ($scope$right = this.matchlogicalTerm($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.logicalExpression_1, left: $scope$left, operator: $scope$operator, right: $scope$right};
                }
                return $$res;
            }, $$cr)();
    }
    public matchlogicalExpression_2($$dpth: number, $$cr?: ContextRecorder): Nullable<logicalExpression_2> {
        return this.runner<logicalExpression_2>($$dpth,
            (log) => {
                if (log) {
                    log("logicalExpression_2");
                }
                let $scope$right: Nullable<logicalTerm>;
                let $$res: Nullable<logicalExpression_2> = null;
                if (true
                    && ($scope$right = this.matchlogicalTerm($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.logicalExpression_2, right: $scope$right};
                }
                return $$res;
            }, $$cr)();
    }
    public test(): boolean {
        const mrk = this.mark();
        const res = this.matchstart(0);
        const ans = res !== null && this.finished();
        this.reset(mrk);
        return ans;
    }
    public parse(): ParseResult {
        const mrk = this.mark();
        const res = this.matchstart(0);
        if (res && this.finished()) {
            return new ParseResult(res, null);
        }
        this.reset(mrk);
        const rec = new ErrorTracker();
        this.matchstart(0, rec);
        return new ParseResult(res,
            rec.getErr() ?? new SyntaxErr(this.mark(), new Set(["$EOF"]), new Set([])));
    }
    public mark(): PosInfo {
        return this.pos;
    }
    private loop<T>(func: $$RuleType<T>, star: boolean = false): Nullable<T[]> {
        const mrk = this.mark();
        const res: T[] = [];
        for (;;) {
            const t = func();
            if (t === null) {
                break;
            }
            res.push(t);
        }
        if (star || res.length > 0) {
            return res;
        }
        this.reset(mrk);
        return null;
    }
    private runner<T>($$dpth: number, fn: $$RuleType<T>, cr?: ContextRecorder): $$RuleType<T> {
        return () => {
            const mrk = this.mark();
            const res = cr ? (() => {
                const extraInfo: string[] = [];
                const result = fn((msg: string) => extraInfo.push(msg));
                cr.record(mrk, $$dpth, result, this.negating, extraInfo);
                return result;
            })() : fn();
            if (res !== null) {
                return res;
            }
            this.reset(mrk);
            return null;
        };
    }
    private choice<T>(fns: Array<$$RuleType<T>>): Nullable<T> {
        for (const f of fns) {
            const res = f();
            if (res !== null) {
                return res;
            }
        }
        return null;
    }
    private regexAccept(match: string, dpth: number, cr?: ContextRecorder): Nullable<string> {
        return this.runner<string>(dpth,
            (log) => {
                if (log) {
                    if (this.negating) {
                        log("$$!StrMatch");
                    } else {
                        log("$$StrMatch");
                    }
                    // We substring from 3 to len - 1 to strip off the
                    // non-capture group syntax added as a WebKit workaround
                    log(match.substring(3, match.length - 1));
                }
                const reg = new RegExp(match, "y");
                reg.lastIndex = this.mark().overallPos;
                const res = reg.exec(this.input);
                if (res) {
                    let lineJmp = 0;
                    let lind = -1;
                    for (let i = 0; i < res[0].length; ++i) {
                        if (res[0][i] === "\n") {
                            ++lineJmp;
                            lind = i;
                        }
                    }
                    this.pos = {
                        overallPos: reg.lastIndex,
                        line: this.pos.line + lineJmp,
                        offset: lind === -1 ? this.pos.offset + res[0].length : (res[0].length - lind - 1)
                    };
                    return res[0];
                }
                return null;
            }, cr)();
    }
    private noConsume<T>(fn: $$RuleType<T>): Nullable<T> {
        const mrk = this.mark();
        const res = fn();
        this.reset(mrk);
        return res;
    }
    private negate<T>(fn: $$RuleType<T>): Nullable<boolean> {
        const mrk = this.mark();
        const oneg = this.negating;
        this.negating = !oneg;
        const res = fn();
        this.negating = oneg;
        this.reset(mrk);
        return res === null ? true : null;
    }
}
export function parse(s: string): ParseResult {
    const p = new Parser(s);
    return p.parse();
}
export class ParseResult {
    public ast: Nullable<start>;
    public err: Nullable<SyntaxErr>;
    constructor(ast: Nullable<start>, err: Nullable<SyntaxErr>) {
        this.ast = ast;
        this.err = err;
    }
}
export interface PosInfo {
    readonly overallPos: number;
    readonly line: number;
    readonly offset: number;
}
export class SyntaxErr {
    public pos: PosInfo;
    public exprules: string[];
    public expmatches: string[];
    constructor(pos: PosInfo, exprules: Set<string>, expmatches: Set<string>) {
        this.pos = pos;
        this.exprules = [...exprules];
        this.expmatches = [...expmatches];
    }
    public toString(): string {
        return `Syntax Error at line ${this.pos.line}:${this.pos.offset}. Tried to match rules ${this.exprules.join(", ")}. Expected one of ${this.expmatches.map((x) => ` '${x}'`)}`;
    }
}
class ErrorTracker implements ContextRecorder {
    private mxpos: PosInfo = {overallPos: -1, line: -1, offset: -1};
    private mnd: number = -1;
    private prules: Set<string> = new Set();
    private pmatches: Set<string> = new Set();
    public record(pos: PosInfo, depth: number, result: any, negating: boolean, extraInfo: string[]) {
        if ((result === null) === negating) {
            return;
        }
        if (pos.overallPos > this.mxpos.overallPos) {
            this.mxpos = pos;
            this.mnd = depth;
            this.pmatches.clear();
            this.prules.clear();
        } else if (pos.overallPos === this.mxpos.overallPos && depth < this.mnd) {
            this.mnd = depth;
            this.prules.clear();
        }
        if (this.mxpos.overallPos === pos.overallPos && extraInfo.length >= 2) {
            if (extraInfo[0] === "$$StrMatch") {
                this.pmatches.add(extraInfo[1]);
            }
            if (extraInfo[0] === "$$!StrMatch") {
                this.pmatches.add(`not ${extraInfo[1]}`);
            }
        }
        if (this.mxpos.overallPos === pos.overallPos && this.mnd === depth) {
            extraInfo.forEach((x) => { if (x !== "$$StrMatch" && x !== "$$!StrMatch") { this.prules.add(x); } });
        }
    }
    public getErr(): SyntaxErr | null {
        if (this.mxpos.overallPos !== -1) {
            return new SyntaxErr(this.mxpos, this.prules, this.pmatches);
        }
        return null;
    }
}